// $Id: Postfix.h,v 1.15 2013/02/09 19:00:35 david Exp $ -*- c++ -*-
#ifndef __CDK8_GENERATOR_POSTFIX_H__
#define __CDK8_GENERATOR_POSTFIX_H__

#include <iostream>
#include <string>

namespace cdk {
  namespace generator {

    /**
     * The postfix code generator defines an interface to be used by semantic
     * analysers, as defined by the strategy design pattern. Specific
     * implementations will provide the realization of the postfix commands for a
     * particular target machine.
     *
     * <h3>Rotation and shift instructions</h3>
     * Shift and rotation operations have as maximum value the number of bits of the
     * underlying processor register (32 bits in a ix86-family processor). Safe
     * operation for values above is not guaranteed.
     *
     * These operations use two values from the stack: the value at the top specifies
     * the number of bits to rotate/shift; the second from the top is the value to be
     * rotated/shifted.
     *
     * <h3>Logical instructions</h3>
     *
     * Logical instructions perform logical operations using the elements at the
     * top of the stack. Arguments are taken from the stack, the result is put on the
     * stack.
     *
     * <h3>Type conversion instructions</h3>
     *
     * Type conversion instructions perform elementary type conversions. The conversions
     * are from and to integers and simple and double precision floating point values.
     *
     * <h3>Integer comparison instructions</h3>
     *
     * The comparison instructions are binary operations that leave at the top of the
     * stack 0 (zero) or 1 (one), depending on the result result of the comparison:
     * respectively, <tt>false</tt> or <tt>true</tt>. The value may be directly used
     * to perform conditional jumps (e.g., JZ, JNZ), that use the value of the top of
     * the stack instead of relying on special processor registers (<i>flags</i>).
     *
     * <h3>Function definition instructions</h3>
     *
     * In a stack machine the arguments for a function call are already in the stack.
     * Thus, it is not necessary to put them there (it is enough not to remove them).
     * When building functions that conform to the C calling convetions,
     * those arguments are destroyed by the caller, <i>after</i> the return of the
     * callee, using <tt>TRASH</tt>, stating the total size (i.e., for all
     * arguments). Regarding the callee, it must create a distinct activation
     * register <tt>ENTER</tt> or <tt>START</tt>) and, when no longer
     * needed, destroy it (<tt>LEAVE</tt>). The latter action must be
     * performed immediately before returning control to the caller.
     *
     * Similarly, to return values from a function, the callee must call
     * <tt>POP</tt> to store the return value in the accumulator register, so
     * that it survives the destruction of the invocation context. The caller must
     * call <tt>PUSH</tt>, to put the accumulator in the stack. An analogous
     * procedure is valid for <tt>DPOP/DPUSH</tt> (for double precision floating point return
     * values).
     *
     * <h3>Addressing instructions</h3>
     *
     * Note [*4*] that these operations (ADDR, LOCAL) put at the top of the stack the
     * symbol's address, independently of its origin. O endereço pode posteriormente
     * ser utilizado como ponteiro, obtido o valor nesse endereço (LOAD) ou guardar
     * um valor nesse endereço (STORE). No entanto, nas duas últimas situações,
     * devido à frequência com que ocorrem e o número de ciclos de relógio que levam
     * a executar, podem ser substituídas com vantagem pela operações descritas em
     * [*10*].
     *
     * "Quick opcodes" are shortcuts for groups of operations commonly used
     * together. These opcodes may be made efficient by implementing them in
     * different ways than the original set of high-level operations would suggest,
     * i.e., the code generated by <tt>ADDRV</tt> may be more efficient than
     * the code generated by <tt>ADDR</tt> followed by <tt>LOAD</tt>.
     * Nevertheless, the outcome is the same.
     *
     * <h3>Load instructions</h3>
     *
     * The load instructions assume that the top of the stack contains an address
     * pointing to the data to be read. Each load instruction will replace the
     * address at the top of the stack with the contents of the position it points
     * to. Load instructions differ only in what they load.
     *
     * <h3>Store instructions</h3>
     *
     * Store instructions assume the stack contains at the top the address where
     * data is to be stored. That data is in the stack, immediately after (below) the
     * address. Store instructions differ only in what they store.
     *
     * <h3>Labels</h3>
     *
     * In a declaration of a symbol common to more than one module, other modules may
     * also contain common or external declarations. Nevertheless, only one
     * initialized declaration is allowed. Declarations need not be associated with
     * any particular segments.
     *
     * In a declaration common to several modules, any number of modules may
     * contain common or external declarations, but only one of them may
     * contain an initialized declaration. A declaration does not need to be
     * specified in a specific segment.
     */
    class Postfix {
    protected:
      /**
       * The output stream for the postfix commands.
       */
      std::ostream &_os;

      //! Debug flag
      bool _debug;

      inline Postfix(std::ostream &o, bool debug = false) :
          _os(o), _debug(debug) {
      }
      inline std::ostream &os() {
        return _os;
      }

    public:
      /**
       * Destructor: the only action is to flush the output stream.
       */
      virtual ~Postfix() {
        os().flush();
      }

    public:
      // miscellaneous
      virtual void NOP() = 0;

      /**
       * Pushes a integer value to the stack top.
       *
       * @param value is the value to be put in the stack.
       */
      virtual void INT(int value) = 0;

      /**
       * Adds <tt>value</tt> to the value at the position defined by the address at
       * the top of the stack, i.e. <tt>[a]</tt> becomes <tt>[a]+value</tt>.
       *
       * @param value is the value to be added.
       */
      virtual void INCR(int value) = 0;

      /**
       * Subtracts <tt>value</tt> from the value at the position defined by the
       * address at the top of the stack, i.e. <tt>[a]</tt> becomes <tt>[a]-value</tt>.
       *
       * @param value is the value to be subtracted.
       */
      virtual void DECR(int value) = 0;

      /**
       * Duplicates the value at the top of the stack.
       */
      virtual void DUP() = 0;

      /**
       * Duplicates the double precision value at the top of the stack.
       */
      virtual void DDUP() = 0;

      /**
       * Exchanges the two elements at the top of the stack.
       */
      virtual void SWAP() = 0;

      /**
       * Pushes to the stack the value of the stack pointer.
       */
      virtual void SP() = 0;

      /**
       * No action is performed.
       */
      virtual void NIL() = 0;

      /**
       * Declares an uninitialized vector with the length (in bytes) given as argument.
       *
       * @param value is the vector's length.
       */
      virtual void BYTE(int value) = 0;

      /**
       * Declares a static character.
       *
       * @param value is the character to be declared.
       */
      virtual void CHAR(char value) = 0;

      /**
       * Declares a static integer value.
       *
       * @param value is the number to be declared.
       */
      virtual void CONST(int value) = 0;

      /**
       * Declares a static simple precision floating point value.
       *
       * @param value is the number to be declared.
       */
      virtual void FLOAT(float value) = 0;

      /**
       * Declares a static double precision floating point value.
       *
       * @param value is the number to be declared.
       */
      virtual void DOUBLE(double value) = 0;

      /**
       * Declares a name for an address.
       *
       * @param label is the name to be declared.
       */
      virtual void ID(std::string label) = 0;

      /**
       * Declares a static character string (no special characters are allowed in <tt>value</tt>).
       *
       * @param value is the string to be declared.
       */
      virtual void STR(std::string value) = 0;

    public:
      // arithmetic
      /**
       * Arithmetic instruction: integer sum of two integer values.
       */
      virtual void ADD() = 0;
      /**
       * Arithmetic instruction: floating point sum of two double values.
       */
      virtual void DADD() = 0;
      /**
       * Arithmetic instruction: floating point division of two double values.
       */
      virtual void DDIV() = 0;
      /**
       * Arithmetic instruction: integer division of two integer values.
       */
      virtual void DIV() = 0;
      /**
       * Arithmetic instruction: floating point multiplication of two double values.
       */
      virtual void DMUL() = 0;
      /**
       * Arithmetic instruction: floating point negation of double value (symmetric).
       */
      virtual void DNEG() = 0;
      /**
       * Arithmetic instruction: floating point subtraction of two double values.
       */
      virtual void DSUB() = 0;
      /**
       * Arithmetic instruction: remainder of integer division of two integer values.
       */
      virtual void MOD() = 0;
      /**
       * Arithmetic instruction: integer multiplication of two integer values.
       */
      virtual void MUL() = 0;
      /**
       * Arithmetic instruction: negation (symmetric) of integer value.
       */
      virtual void NEG() = 0;
      /**
       * Arithmetic instruction: integer subtraction of two integer values.
       */
      virtual void SUB() = 0;
      /**
       * Arithmetic instruction: integer division of two natural (integer) values.
       */
      virtual void UDIV() = 0;
      /**
       * Arithmetic instruction: remainder of integer division of two natural (integer) values.
       */
      virtual void UMOD() = 0;

    public:
      // shift
      /**
       * Rotation and shift instructions: left rotation of stack top.
       */
      virtual void ROTL() = 0;
      /**
       * Rotation and shift instructions: right rotation of stack top.
       */
      virtual void ROTR() = 0;
      /**
       * Rotation and shift instructions: left shift of stack top.
       */
      virtual void SHTL() = 0;
      /**
       * Rotation and shift instructions: right shift of stack top (signed).
       */
      virtual void SHTRS() = 0;
      /**
       * Rotation and shift instructions: right shift of stack top (unsigned).
       */
      virtual void SHTRU() = 0;

    public:
      // conversion
      /**
       * Type conversion instructions: converts from double precision floating point to simple precision floating point.
       */
      virtual void D2F() = 0;
      /**
       * Type conversion instructions: converts from double precision floating point to integer.
       */
      virtual void D2I() = 0;
      /**
       * Type conversion instructions: converts from simple precision floating point to double precision floating point.
       */
      virtual void F2D() = 0;
      /**
       * Type conversion instructions: converts from integer to double precision floating point.
       */
      virtual void I2D() = 0;

    public:
      // logical
      /**
       * Logical instructions: logical (bitwise) AND operation.
       */
      virtual void AND() = 0;
      /**
       * Logical instructions: logical negation (bitwise), i.e., one's complement.
       */
      virtual void NOT() = 0;
      /**
       * Logical instructions: logical (bitwise) OR operation.
       */
      virtual void OR() = 0;
      /**
       * Logical instructions: logical (bitwise) XOR operation.
       */
      virtual void XOR() = 0;

    public:
      // comparison
      /**
       * Compares two double precision floating point values. The result is an
       * integer value: less than 0, if the <tt>d1</tt> is less than <tt>d2</tt>;
       * 0, if they are equal; greater than 0, otherwise.
       */
      virtual void DCMP() = 0;
      /**
       * Integer comparison instructions: <i>equal to</i>.
       */
      virtual void EQ() = 0;
      /**
       * Integer comparison instructions: <i>greater than or equal to</i>.
       */
      virtual void GE() = 0;
      /**
       * Integer comparison instructions: <i>greater than</i>.
       */
      virtual void GT() = 0;
      /**
       * Integer comparison instructions: <i>less than or equal to</i>.
       */
      virtual void LE() = 0;
      /**
       * Integer comparison instructions: <i>less than</i>.
       */
      virtual void LT() = 0;
      /**
       * Integer comparison instructions: <i>not equal to</i>.
       */
      virtual void NE() = 0;
      /**
       * Integer comparison instructions: <i>greater than or equal to</i> for natural numbers (unsigned integers).
       */
      virtual void UGE() = 0;
      /**
       * Integer comparison instructions: <i>greater than</i> for natural numbers (unsigned integers).
       */
      virtual void UGT() = 0;
      /**
       * Integer comparison instructions: <i>less than or equal to</i> for natural numbers (unsigned integers).
       */
      virtual void ULE() = 0;
      /**
       * Integer comparison instructions: <i>less than</i> for natural numbers (unsigned integers).
       */
      virtual void ULT() = 0;

    public:
      // functions
      /**
       * Function definition instructions: starts a function: push the frame pointer
       * (activation register) to the stack and allocate space for local variables,
       * according to the size given as argument (in bytes).
       *
       * @param bytes is the space to be allocated for local variables.
       */
      virtual void ENTER(size_t bytes) = 0;
      /**
       * Function definition instructions: equivalent to <tt>ENTER(0)</tt>.
       */
      virtual void START() = 0;
      /**
       * Function definition instructions: ends a function: restores the frame pointer
       * (activation register) and destroys the function-local stack data.
       */
      virtual void LEAVE() = 0;
      /**
       * Function definition instructions: removes a value from the stack (to the accumulator register).
       */
      virtual void POP() = 0;
      /**
       * Function definition instructions: pushes the value in the accumulator register to the stack.
       */
      virtual void PUSH() = 0;
      /**
       * Function definition instructions: removes a double precision floating point value from the stack (to a double prevision floating point register).
       */
      virtual void DPOP() = 0;
      /**
       * Function definition instructions: pushes the value in the double precision floating point register to the stack.
       */
      virtual void DPUSH() = 0;
      /**
       * Function definition instructions: returns from a function (the stack should contain the return address).
       */
      virtual void RET() = 0;
      /**
       * Function definition instructions: returns from a function, but removes
       * <tt>n</tt> bytes from the stack after removing the return address.
       * More or less the same as <tt>RET()</tt> followed by <tt>TRASH(n)</tt>.
       *
       * @param bytes the number of bytes to take from the stack.
       */
      virtual void RETN(int bytes) = 0;

      /**
       * Function definition instructions: removes <tt>n</tt> bytes from the stack.
       *
       * @param bytes the number of bytes to take from the stack.
       */
      virtual void TRASH(int bytes) = 0;

    public:
      // functions
      /**
       * Calls the named function. Stores the return address in the stack.
       *
       * @param label is the called function's name.
       */
      virtual void CALL(std::string label) = 0;

    public:
      // addressing
      /**
       * Allocates in the stack as many bytes as indicated by the value at the top of the stack.
       *
       * Dynamic memory allocation in the stack, equivalent to a call to the
       * C language <tt>alloca</tt> function, changes the offsets of temporary
       * variables that may exist in the stack when the allocation is performed. Thus,
       * it should only be used when no temporary variables exist, or when the full
       * import of its actions is fully understood.
       */
      virtual void ALLOC() = 0;

      /**
       * AAbsolute addressing instruction: puts the address of the name passed as argument at the top of the stack.
       *
       * Absolute addressing <tt>ADDR</tt>) is performed using labels. Relative
       * addressing (<tt>LOCAL</tt>) requires a frame pointer to work: the frame
       * pointer defines an addressing reference.
       *
       * @param label is the name of the memory position.
       * @see LOCAL
       */
      virtual void ADDR(std::string label) = 0;

      /**
       * Absolute addressing instruction: quick opcode: the same as the sequence <tt>ADDR(name); STORE();</tt>
       *
       * @param label is the name of the memory position.
       * @see ADDR STORE
       */
      virtual void ADDRA(std::string label) = 0;

      /**
       * Absolute addressing instruction: quick opcode: the same as the sequence <tt>ADDR(name); LOAD();</tt>
       *
       * @param label is the name of the memory position.
       * @see ADDR LOAD
       */
      virtual void ADDRV(std::string label) = 0;

      /**
       * Relative addressing instruction: puts at the top of the stack
       * the address of the local variable, obtained by computing the
       * offset relative to the frame pointer.
       *
       * The value passed as argument is as follows: greater of equal to
       * 8, means function arguments; equal to 4, means the function's
       * return address; equal to 0, means the frame pointer itself; less
       * that -4, means local variables.
       *
       * @param offset from the top of the stack.
       */
      virtual void LOCAL(int offset) = 0;

      /**
       * Relative addressing instruction: quick opcode: the same as the sequence <tt>LOCAL(offset); STORE();</tt>
       *
       * @param offset from the top of the stack.
       * @see LOCAL STORE
       */
      virtual void LOCA(int offset) = 0;

      /**
       * Relative addressing instruction: quick opcode: the same as the sequence <tt>ADDR(name); LOAD();</tt>
       *
       * @param offset from the top of the stack.
       * @see LOCAL LOAD
       */
      virtual void LOCV(int offset) = 0;

      /**
       * Load instruction: loads 1 byte (char).
       */
      virtual void LDCHR() = 0;

      /**
       * Load instruction: loads 1 byte (without sign) (unsigned char).
       */
      virtual void ULDCHR() = 0;

      /**
       * Load instruction: loads 2 bytes (short).
       */
      virtual void LD16() = 0;

      /**
       * Load instruction: loads 2 bytes (without sign) (unsigned short).
       */
      virtual void ULD16() = 0;

      /**
       * Load instruction: loads 4 bytes (integer -- rvalue).
       */
      virtual void LOAD() = 0;

      /**
       * Load instruction: loads a double precision floating point value.
       */
      virtual void DLOAD() = 0;

      /**
       * Store instruction: stores 1 byte (char).
       */
      virtual void STCHR() = 0;

      /**
       * Store instruction: stores 2 bytes (short).
       */
      virtual void ST16() = 0;

      /**
       * Store instruction: stores 4 bytes (integer).
       */
      virtual void STORE() = 0;

      /**
       * Store instruction: stores a double precision floating point value.
       */
      virtual void DSTORE() = 0;

    public:
      // segments
      /**
       * Starts the data segment for uninitialized values.
       */
      virtual void BSS() = 0;

      /**
       * Starts the data segment for initialized values.
       */
      virtual void DATA() = 0;

      /**
       * Starts the data segment for initialized constant values.
       */
      virtual void RODATA() = 0;

      /**
       * Starts the text (code) segment.
       */
      virtual void TEXT() = 0;

    public:
      // labels
      /**
       * Forces the alignment of code or data.
       */
      virtual void ALIGN() = 0;

      /**
       * Generates a new label, as indicated by the argument.
       *
       * @param label is the new label's name.
       */
      virtual void LABEL(std::string label) = 0;

      /**
       * Declares the symbol whose name is passed as argument as being externally defined, i.e., defined in another compilation module.
       *
       * @param label is the symbol's name.
       */
      virtual void EXTERN(std::string label) = 0;

      /**
       * Declare a name/label (first argument) with a given type (second argument; see below).
       * Declaration of a name must preceed its definition.
       *
       * @param label is the name to be defined.
       * @param type is the named object's type.
       * @see  FUNC OBJ NONE
       */
      virtual void GLOBAL(const char *label, std::string type) = 0;

      /**
       * Declare a name/label (first argument) with a given type (second argument; see below).
       * Declaration of a name must preceed its definition. This is the C++-friendly interface.
       *
       * @param label is the name to be defined.
       * @param type is the named object's type.
       * @see  FUNC OBJ NONE
       */
      virtual void GLOBAL(std::string label, std::string type) = 0;

      /**
       * Declares that a name is common to other modules.
       *
       * @param value ...
       */
      virtual void COMMON(int value) = 0;

    public:
      // jumps
      virtual void BRANCH() = 0;
      virtual void JEQ(std::string) = 0;
      virtual void JGE(std::string) = 0;
      virtual void JGT(std::string) = 0;
      virtual void JLE(std::string) = 0;
      virtual void JLT(std::string) = 0;
      virtual void JMP(std::string) = 0;
      virtual void JNE(std::string) = 0;
      virtual void JNZ(std::string) = 0;
      virtual void JUGE(std::string) = 0;
      virtual void JUGT(std::string) = 0;
      virtual void JULE(std::string) = 0;
      virtual void JULT(std::string) = 0;
      virtual void JZ(std::string) = 0;
      virtual void LEAP() = 0;

    public:
      /* The following are used as the 2nd argument of GLOBL */

      /* unknown global label type */
      inline virtual std::string NONE() const {
        return "";
      }

      /* global label is a function */
      inline virtual std::string FUNC() const {
        return ":function";
      }

      /* global label is data */
      inline virtual std::string OBJ() const {
        return ":object";
      }

    };

  } // namespace generator
} // namespace cdk

#endif

// $Log: Postfix.h,v $
// Revision 1.15  2013/02/09 19:00:35  david
// First CDK8 commit. Major code simplification.
// Starting C++11 implementation.
//
// Revision 1.14  2012/04/10 19:01:05  david
// Removed initialization-dependent static members in factories.
// Handling of ProgramNodes is now better encapsulated by visitors (not done
// by evaluators, as before). Major cleanup (comments).
//
// Revision 1.13  2012/03/06 15:07:46  david
// Added subtype to ExpressionType. This allows for more expressiveness in
// type description.
//
// Revision 1.12  2012/02/18 19:38:59  david
// This is the first commit in CDK7. Evaluators and code generators are now aware
// of the debug command line options.
//
